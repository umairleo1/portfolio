name: Release Management

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

# Prevent concurrent releases
concurrency:
  group: 'release-${{ github.ref }}'
  cancel-in-progress: false

jobs:
  # Security Scanning Job
  security:
    name: Security Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read # Required to checkout code
      security-events: write # Required for CodeQL and SARIF uploads
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0 # Full history for security analysis

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4.30.9
        with:
          languages: javascript-typescript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4.30.9

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'fs'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v4.30.9
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Quality Gates
  quality:
    name: Quality Gates
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: security
    permissions:
      contents: read # Required to checkout code
    strategy:
      matrix:
        node-version: [20, 22]
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v5.0.0
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Run ESLint
        run: npm run lint

      - name: Run TypeScript check
        run: npm run type-check

      - name: Run tests with coverage
        run: npm run test:ci

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5.1.1
        if: matrix.node-version == 20
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false

      - name: Security audit
        run: npm run security:audit:prod

  # Build
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [security, quality]
    permissions:
      contents: write # Required for version detection
      actions: write # Required to upload build artifacts
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js 20 LTS
        uses: actions/setup-node@v5.0.0
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Get next version
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          echo "Running semantic-release dry-run..."
          echo "Commits since last tag:"
          git log --oneline $(git describe --tags --abbrev=0 2>/dev/null || echo "HEAD~10")..HEAD

          DRY_RUN_OUTPUT=$(npx semantic-release --dry-run --debug 2>&1) || {
            echo "::error::Semantic release dry run failed"
            echo "::group::Dry run output"
            echo "$DRY_RUN_OUTPUT"
            echo "::endgroup::"
            echo "dry_run_failed=true" >> $GITHUB_OUTPUT
            echo "version=skip" >> $GITHUB_OUTPUT
            echo "::warning::Semantic release dry run failed - no release will be created"
            exit 0
          }

          NEXT_VERSION=$(echo "$DRY_RUN_OUTPUT" | grep -oP 'The next release version is \K(v)?\d+\.\d+\.\d+' || echo "")

          if [ -z "$NEXT_VERSION" ]; then
            echo "No version found - no release needed"
            echo "version=skip" >> $GITHUB_OUTPUT
            echo "dry_run_failed=false" >> $GITHUB_OUTPUT
            echo "::notice::No conventional commits found - skipping release"
          else
            CLEAN_VERSION=${NEXT_VERSION#v}
            echo "version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
            echo "dry_run_failed=false" >> $GITHUB_OUTPUT
            echo "Next version will be: $CLEAN_VERSION"
          fi

      - name: Build with version
        if: steps.version.outputs.version != 'skip'
        run: npm run build
        timeout-minutes: 15
        env:
          PUBLIC_URL: /portfolio
          NODE_ENV: production
          GENERATE_SOURCEMAP: false
          INLINE_RUNTIME_CHUNK: false
          REACT_APP_VERSION: ${{ steps.version.outputs.version }}
          REACT_APP_BUILD_TIME: ${{ github.run_number }}
          REACT_APP_COMMIT_SHA: ${{ github.sha }}
          # Your existing secrets
          REACT_APP_GOOGLE_ANALYTICS_ID: ${{ secrets.REACT_APP_GOOGLE_ANALYTICS_ID }}
          REACT_APP_EMAILJS_SERVICE_ID: ${{ secrets.REACT_APP_EMAILJS_SERVICE_ID }}
          REACT_APP_EMAILJS_TEMPLATE_ID: ${{ secrets.REACT_APP_EMAILJS_TEMPLATE_ID }}
          REACT_APP_EMAILJS_PUBLIC_KEY: ${{ secrets.REACT_APP_EMAILJS_PUBLIC_KEY }}

      - name: Upload build for release
        if: steps.version.outputs.version != 'skip'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: build/
          retention-days: 7

  # Semantic Release
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    needs: [quality, build]
    if: github.ref == 'refs/heads/main' && needs.build.outputs.version != 'skip'
    timeout-minutes: 10
    permissions:
      contents: write # Required to create tags and release commits
      actions: read # Required to download build artifacts
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
      release_failed: ${{ steps.semantic.outputs.release_failed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch semantic-release notes
        run: git fetch origin refs/notes/semantic-release*:refs/notes/semantic-release* || true

      - name: Setup Node.js
        uses: actions/setup-node@v5.0.0
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: build-artifacts
          path: build/

      - name: Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Starting semantic release..."
          echo "Commits to be released:"
          git log --oneline $(git describe --tags --abbrev=0 2>/dev/null || echo "HEAD~5")..HEAD

          # Run semantic release and capture both output and exit code
          set +e  # Temporarily disable exit on error
          RELEASE_OUTPUT=$(npx semantic-release --debug 2>&1) 
          RELEASE_EXIT_CODE=$?
          set -e  # Re-enable exit on error for remaining commands

          echo "::group::Semantic Release Output"
          echo "$RELEASE_OUTPUT"
          echo "::endgroup::"

          # Handle different scenarios
          if [ $RELEASE_EXIT_CODE -eq 0 ]; then
            if echo "$RELEASE_OUTPUT" | grep -q "Published release"; then
              # Success: Release was published
              echo "new_release_published=true" >> $GITHUB_OUTPUT
              echo "release_failed=false" >> $GITHUB_OUTPUT
              
              RELEASE_VERSION=$(echo "$RELEASE_OUTPUT" | grep -oP 'Published release \K(v)?\d+\.\d+\.\d+' || echo "unknown")
              CLEAN_VERSION=${RELEASE_VERSION#v}
              echo "new_release_version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
              echo "::notice::Semantic release completed successfully - version $CLEAN_VERSION"
            else
              # Success: No release needed (no qualifying commits)
              echo "new_release_published=false" >> $GITHUB_OUTPUT
              echo "release_failed=false" >> $GITHUB_OUTPUT
              echo "::notice::Semantic release completed - no release needed"
            fi
          else
            # Failure: Semantic release encountered an error
            echo "new_release_published=false" >> $GITHUB_OUTPUT
            echo "release_failed=true" >> $GITHUB_OUTPUT
            echo "::error::Semantic release failed with exit code $RELEASE_EXIT_CODE"
            exit 1
          fi

  # Deploy
  deploy:
    name: Deploy to GitHub Pages
    runs-on: ubuntu-latest
    needs: [build, release]
    if: needs.release.outputs.new_release_published == 'true' && needs.release.outputs.release_failed != 'true'
    timeout-minutes: 15
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    permissions:
      contents: read # Required for basic access
      pages: write # Required for GitHub Pages deployment
      id-token: write # Required for OIDC authentication
      actions: read # Required to download build artifacts
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: build-artifacts
          path: build/

      - name: Validate build artifacts
        run: |
          if [ ! -d "build" ] || [ -z "$(ls -A build)" ]; then
            echo "::error::Build artifacts are missing or empty"
            exit 1
          fi
          echo "::notice::Build artifacts validated successfully"
          ls -la build/

      - name: Setup GitHub Pages
        uses: actions/configure-pages@v5.0.0

      - name: Upload to GitHub Pages
        uses: actions/upload-pages-artifact@v4.0.0
        with:
          path: build/

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4.0.5
        with:
          timeout: 600000
          error_count: 10
          reporting_interval: 5

      - name: Deployment Summary
        if: success()
        run: |
          echo "## Deployment Successful" >> $GITHUB_STEP_SUMMARY
          # Safe version access with fallback
          VERSION="${{ needs.release.outputs.new_release_version || 'latest' }}"
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy URL**: ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Time**: $(date)" >> $GITHUB_STEP_SUMMARY

      - name: Deployment Failed
        if: failure()
        run: |
          echo "## Deployment Failed" >> $GITHUB_STEP_SUMMARY
          # Safe version access with fallback
          VERSION="${{ needs.release.outputs.new_release_version || 'unknown' }}"
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Error**: Deployment to GitHub Pages failed" >> $GITHUB_STEP_SUMMARY
          echo "- **Action Required**: Check deployment logs and retry if necessary" >> $GITHUB_STEP_SUMMARY
          echo "::error::Deployment failed for version $VERSION"

  # Monitor
  monitor:
    name: Performance and Security Monitor
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [deploy, release]
    if: needs.deploy.result == 'success' && github.ref == 'refs/heads/main'
    permissions:
      contents: read # Required to checkout code
    steps:
      - name: Checkout for monitoring
        uses: actions/checkout@v5.0.0

      - name: Install jq for JSON parsing
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Lighthouse CI with advanced config
        uses: treosh/lighthouse-ci-action@v12
        with:
          urls: |
            ${{ github.event.repository.homepage || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}
          configPath: './.lighthouserc.json'
          uploadArtifacts: true
          temporaryPublicStorage: true

      - name: Generate performance report
        run: |
          echo "## Performance & Security Monitoring" >> $GITHUB_STEP_SUMMARY
          # Safe version access with fallback
          VERSION="${{ needs.release.outputs.new_release_version || 'latest' }}"
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Site URL**: ${{ github.event.repository.homepage || format('https://{0}.github.io/{1}', github.repository_owner, github.event.repository.name) }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring Time**: $(date)" >> $GITHUB_STEP_SUMMARY

          # Extract Lighthouse performance metrics if available
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Performance Metrics" >> $GITHUB_STEP_SUMMARY

          # Check multiple possible Lighthouse report locations
          REPORT_FILE=""
          if [ -f "lhci_reports/manifest.json" ]; then
            REPORT_FILE="lhci_reports/manifest.json"
          elif [ -f ".lighthouseci/manifest.json" ]; then
            REPORT_FILE=".lighthouseci/manifest.json"
          elif [ -f "lighthouse-results.json" ]; then
            REPORT_FILE="lighthouse-results.json"
          fi

          if [ -n "$REPORT_FILE" ] && [ -f "$REPORT_FILE" ]; then
            echo "Found Lighthouse report: $REPORT_FILE"
            
            # Find median run (isRepresentativeRun=true) for accurate scores
            MEDIAN_ENTRY=$(jq -r 'map(select(.isRepresentativeRun == true)) | .[0] // empty' "$REPORT_FILE" 2>/dev/null)
            
            if [ -n "$MEDIAN_ENTRY" ] && [ "$MEDIAN_ENTRY" != "null" ]; then
              # Extract scores from median run (0-1 scale, convert to 0-100)
              PERF_SCORE=$(echo "$MEDIAN_ENTRY" | jq -r '.summary.performance // 0 | . * 100 | round')
              ACCESSIBILITY=$(echo "$MEDIAN_ENTRY" | jq -r '.summary.accessibility // 0 | . * 100 | round')
              BEST_PRACTICES=$(echo "$MEDIAN_ENTRY" | jq -r '.summary."best-practices" // 0 | . * 100 | round')
              SEO_SCORE=$(echo "$MEDIAN_ENTRY" | jq -r '.summary.seo // 0 | . * 100 | round')
              
              TESTED_URL=$(echo "$MEDIAN_ENTRY" | jq -r '.url // "N/A"')
              echo "::notice::Using median run from: $TESTED_URL"
            else
              # Fallback to first entry if no median found
              echo "::warning::No median run found, using first entry"
              PERF_SCORE=$(jq -r '.[0].summary.performance // 0 | . * 100 | round' "$REPORT_FILE" 2>/dev/null || echo "N/A")
              ACCESSIBILITY=$(jq -r '.[0].summary.accessibility // 0 | . * 100 | round' "$REPORT_FILE" 2>/dev/null || echo "N/A")
              BEST_PRACTICES=$(jq -r '.[0].summary."best-practices" // 0 | . * 100 | round' "$REPORT_FILE" 2>/dev/null || echo "N/A")
              SEO_SCORE=$(jq -r '.[0].summary.seo // 0 | . * 100 | round' "$REPORT_FILE" 2>/dev/null || echo "N/A")
            fi
            
            # Extract timing metrics from median run's JSON report if available
            if [ -n "$MEDIAN_ENTRY" ] && [ "$MEDIAN_ENTRY" != "null" ]; then
              JSON_PATH=$(echo "$MEDIAN_ENTRY" | jq -r '.jsonPath // empty')
              if [ -n "$JSON_PATH" ] && [ -f "$JSON_PATH" ]; then
                # Extract from detailed JSON report (ms to seconds)
                FCP=$(jq -r '.audits."first-contentful-paint".numericValue // null | if . then (. / 1000 * 100 | round | . / 100) else "N/A" end' "$JSON_PATH" 2>/dev/null || echo "N/A")
                LCP=$(jq -r '.audits."largest-contentful-paint".numericValue // null | if . then (. / 1000 * 100 | round | . / 100) else "N/A" end' "$JSON_PATH" 2>/dev/null || echo "N/A")
              else
                FCP="N/A"
                LCP="N/A"
              fi
            else
              FCP="N/A"
              LCP="N/A"
            fi
            
            echo "- **Performance Score**: ${PERF_SCORE}/100" >> $GITHUB_STEP_SUMMARY
            echo "- **Accessibility**: ${ACCESSIBILITY}/100" >> $GITHUB_STEP_SUMMARY
            echo "- **Best Practices**: ${BEST_PRACTICES}/100" >> $GITHUB_STEP_SUMMARY
            echo "- **SEO Score**: ${SEO_SCORE}/100" >> $GITHUB_STEP_SUMMARY
            echo "- **First Contentful Paint**: ${FCP}s" >> $GITHUB_STEP_SUMMARY
            echo "- **Largest Contentful Paint**: ${LCP}s" >> $GITHUB_STEP_SUMMARY
          else
            echo "No Lighthouse report found - metrics will be available in next run" >> $GITHUB_STEP_SUMMARY
            echo "- **Performance Score**: Analyzing..." >> $GITHUB_STEP_SUMMARY
            echo "- **Accessibility**: Analyzing..." >> $GITHUB_STEP_SUMMARY
            echo "- **Best Practices**: Analyzing..." >> $GITHUB_STEP_SUMMARY
            echo "- **SEO Score**: Analyzing..." >> $GITHUB_STEP_SUMMARY
            echo "- **First Contentful Paint**: Analyzing..." >> $GITHUB_STEP_SUMMARY
            echo "- **Largest Contentful Paint**: Analyzing..." >> $GITHUB_STEP_SUMMARY
          fi

  # Notify
  notify:
    name: Release Notifications
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [security, quality, build, release, deploy, monitor]
    if: always()
    permissions:
      contents: read # Minimal read access for notifications only
    steps:
      - name: Success Notification
        if: needs.deploy.result == 'success'
        run: |
          echo "## Release Pipeline Completed Successfully" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: All stages completed" >> $GITHUB_STEP_SUMMARY
          # Safe version access with fallback
          VERSION="${{ needs.release.outputs.new_release_version || 'latest' }}"
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Quality Gates**: ${{ needs.quality.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build**: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release**: ${{ needs.release.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment**: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring**: ${{ needs.monitor.result }}" >> $GITHUB_STEP_SUMMARY
          echo "::notice::Release pipeline completed successfully"

      - name: Failure Analysis
        if: contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled')
        run: |
          echo "## Release Pipeline Failed" >> $GITHUB_STEP_SUMMARY
          echo "- **Overall Status**: Failed" >> $GITHUB_STEP_SUMMARY
          echo "- **Quality Gates**: ${{ needs.quality.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build**: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release**: ${{ needs.release.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment**: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring**: ${{ needs.monitor.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Failure Analysis" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.quality.result }}" == "failure" ]]; then
            echo "- **Quality Gates Failed**: Code quality checks did not pass" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.build.result }}" == "failure" ]]; then
            echo "- **Build Failed**: Application build process failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.release.result }}" == "failure" ]]; then
            echo "- **Release Failed**: Semantic release process failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.deploy.result }}" == "failure" ]]; then
            echo "- **Deployment Failed**: GitHub Pages deployment failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.monitor.result }}" == "failure" ]]; then
            echo "- **Monitoring Failed**: Performance and security monitoring failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Recovery Actions" >> $GITHUB_STEP_SUMMARY
          echo "1. Check individual job logs for detailed error messages" >> $GITHUB_STEP_SUMMARY
          echo "2. Fix identified issues" >> $GITHUB_STEP_SUMMARY
          echo "3. Push new conventional commit to trigger another release" >> $GITHUB_STEP_SUMMARY
          echo "4. For emergency fixes, use workflow_dispatch to force deployment" >> $GITHUB_STEP_SUMMARY

          echo "::error::Release pipeline failed - manual intervention required"

      - name: No Release Notification
        if: needs.build.outputs.version == 'skip' && needs.quality.result == 'success'
        run: |
          echo "## No Release Required" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: All checks passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Reason**: No conventional commits found that trigger a release" >> $GITHUB_STEP_SUMMARY
          echo "- **Action**: No action required - this is normal for documentation and maintenance commits" >> $GITHUB_STEP_SUMMARY
          echo "::notice::No release created - no conventional commits found"
